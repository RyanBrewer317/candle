let x: (f: Nat=>Nat) & (f =[Nat=>Nat] (m: Nat)-> m) = [
  (n: Nat)-> n,
  refl(f, Nat=>Nat); 
  (f: Nat=>Nat) & (f =[Nat=>Nat] (m: Nat)-> m)
] in 
let test: Nat = J(.2(x), .1(x), (r: Nat)-> r; Nat=>Nat, 
    <y: Nat=>Nat>-> <p: .1(x) =[Nat=>Nat] y>-> Nat
)(4) in

let Cast<A: Type><B: Type>: Type = (f: A => (A & B)) & ({x: A}=> x =[A] .1(f(x))) in
let CastIrrel{A: Type}{B: Type}{k: Cast<A><B>}: Cast<A><B> = [
  (x: A)-> cast(x, .1(k)(x), .2(k){x}),
  {x: A}-> refl(x, A);
  Cast<A><B>
] in

let N: Type = {X: Type}=> X => (X => X) => X in
let zero{X: Type}(base: X)(step: X => X): X = base in
let succ(n: N){X: Type}(base: X)(step: X=>X): X =
  step(n{X}(base)(step)) 
in

let one: N = succ(zero) in
let two: N = succ(one) in
let three: N = succ(two) in

let add(m: N)(n: N): N = n{N}(m)(succ) in

let lemma: add(one)(one) =[N] two = 
  refl(two, N) 
in


let iNat<n: N>: Type = 
  {P: <N>=>Type}=> (P<zero>) => ((m: N)=> P<m> => P<succ(m)>) => P<n> 
in

let izero{P: <N>=>Type}(base: P<zero>)(step: (m: N)=> P<m> => P<succ(m)>): P<zero> = 
  base 
in

let ione{P: <N>=>Type}(base: P<zero>)(step: (m: N)=> P<m> => P<succ(m)>): P<one> = 
  step(zero)(base) 
in

5