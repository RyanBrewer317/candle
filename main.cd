let x: (f: Nat=>Nat) & (f =[Nat=>Nat] (m: Nat)-> m) = [
  (n: Nat)-> n,
  refl(f, Nat=>Nat); 
  (f: Nat=>Nat) & (f =[Nat=>Nat] (m: Nat)-> m)
] in 
let test: Nat = J(.2(x), .1(x), (r: Nat)-> r; Nat=>Nat, 
    <y: Nat=>Nat>-> <p: .1(x) =[Nat=>Nat] y>-> Nat
)(4) in

let Cast<A: Type><B: Type>: Type = (f: A => (A & B)) & ({x: A}=> x =[A] .1(f(x))) in
let CastIrrel{A: Type}{B: Type}{k: Cast<A><B>}: Cast<A><B> = [
  (x: A)-> cast(x, .1(k)(x), .2(k){x}),
  {x: A}-> refl(x, A);
  Cast<A><B>
] in

let cNat: Type = {X: Type}=> X => (X => X) => X in
let zero{X: Type}(base: X)(step: X => X): X = base in
let succ(n: cNat){X: Type}(base: X)(step: X=>X): X =
  step(n{X}(base)(step)) 
in

let one: cNat = succ(zero) in
let two: cNat = succ(one) in
let three: cNat = succ(two) in

let add(m: cNat)(n: cNat): cNat = n{cNat}(m)(succ) in

let lemma: add(one)(one) =[cNat] two = 
  refl(two, cNat) 
in


let iNat<n: cNat>: Type = 
  {P: <cNat>=>Type}=> (P<zero>) => ((m: cNat)=> P<m> => P<succ(m)>) => P<n> 
in

let izero{P: <cNat>=>Type}(base: P<zero>)(step: (m: cNat)=> P<m> => P<succ(m)>): P<zero> = 
  base 
in

let ione{P: <cNat>=>Type}(base: P<zero>)(step: (m: cNat)=> P<m> => P<succ(m)>): P<one> = 
  step(zero)(base) 
in

5